# GUIÓN PARA VIDEO - EXPLICACIÓN BACKEND

## Información del Video
- **Duración estimada:** 12-15 minutos
- **Tema:** Vistas (Views) y URLs del Backend Django
- **Requisitos:** Servidor corriendo, Postman/Thunder Client preparado

---

## ESTRUCTURA DEL VIDEO

### 1. INTRODUCCIÓN (30 segundos)
**[Pantalla: Tu cara o logo]**

**Guión:**
> "Hola, en este video voy a explicar las vistas y URLs que implementamos en el backend de nuestro sistema escolar. Este backend está desarrollado con Django REST Framework y maneja la autenticación con JWT. Vamos a ver cómo funcionan los endpoints para administradores, maestros y alumnos."

**[Transición a pantalla compartida del IDE]**

---

### 2. MOSTRAR ESTRUCTURA DE ARCHIVOS (30 segundos)
**[Pantalla: Explorador de archivos del proyecto]**

**Guión:**
> "Primero veamos la estructura de nuestro proyecto. Tenemos tres archivos principales que vamos a revisar:"

**Mostrar en pantalla:**
```
app_movil_escolar_api/
├── views/
│   ├── auth.py        ← "Aquí manejamos el login"
│   └── users.py       ← "Aquí está todo el CRUD de usuarios"
├── urls.py            ← "Aquí configuramos las rutas"
└── models.py          ← "Los modelos de datos"
```

**Continuar:**
> "También tenemos el archivo models.py que define nuestra estructura de datos, pero hoy nos enfocaremos en las vistas y rutas."

---

### 3. ARCHIVO URLS.PY (2 minutos)
**[Pantalla: Abrir urls.py en el editor]**

**Guión:**
> "Comencemos con el archivo urls.py. Aquí es donde configuramos todas las rutas de nuestra API REST."

**Mostrar y explicar sección por sección:**

#### 3.1 Importaciones
```python
from app_movil_escolar_api.views import auth
from app_movil_escolar_api.views import users
```

**Decir:**
> "Importamos las vistas que vamos a usar desde los módulos auth y users."

#### 3.2 Ruta de Autenticación
```python
# AUTENTICACIÓN
path('login/', auth.login_view, name='login'),
```

**Decir:**
> "Esta ruta maneja el login. Cuando el frontend hace un POST a /login/, se ejecuta la función login_view que retorna el token JWT."

#### 3.3 Rutas de Administradores
```python
# ADMINISTRADORES
path('api/administrador/registro/', users.AdminView.as_view()),
path('lista-admins/', users.AdminAll.as_view()),
path('administrador-edit/<int:pk>/', users.AdminEdit.as_view()),
```

**Decir mientras señalas cada línea:**
> "Para los administradores tenemos tres rutas principales:"
> - "La primera es para registrar un nuevo administrador con POST"
> - "La segunda lista todos los administradores con GET"
> - "Y la tercera maneja las operaciones individuales: GET para obtener uno, PUT para actualizar y DELETE para eliminar. Aquí usamos `<int:pk>` para capturar el ID del administrador como parámetro en la URL."

#### 3.4 Rutas de Maestros
```python
# MAESTROS
path('api/maestro/registro/', users.MaestroView.as_view()),
path('lista-maestros/', users.MaestroAll.as_view()),
path('maestro-edit/<int:pk>/', users.MaestroEdit.as_view()),
```

**Decir:**
> "Los maestros siguen exactamente el mismo patrón: registro, lista y CRUD individual."

#### 3.5 Rutas de Alumnos
```python
# ALUMNOS
path('api/alumno/registro/', users.AlumnoView.as_view()),
path('lista-alumnos/', users.AlumnoAll.as_view()),
path('alumno-edit/<int:pk>/', users.AlumnoEdit.as_view()),
```

**Decir:**
> "Y finalmente los alumnos también tienen los mismos tres endpoints."

**Destacar:**
> "Todas estas vistas usan `.as_view()` porque son vistas basadas en clases de Django REST Framework. Esto nos permite tener métodos específicos para GET, POST, PUT y DELETE dentro de la misma clase."

---

### 4. ARCHIVO AUTH.PY - LOGIN (3 minutos)
**[Pantalla: Abrir views/auth.py]**

**Guión:**
> "Ahora vamos a ver el archivo auth.py que maneja la autenticación. Aquí tenemos la función login_view."

#### 4.1 Decoradores
```python
@api_view(['POST'])
@permission_classes([AllowAny])
```

**Decir:**
> "Usamos dos decoradores importantes:"
> - "`@api_view(['POST'])` indica que esta vista solo acepta peticiones POST"
> - "`@permission_classes([AllowAny])` significa que no requiere autenticación previa, cualquiera puede hacer login"

#### 4.2 Extraer credenciales
```python
email = request.data.get('email')
password = request.data.get('password')

if not email or not password:
    return Response({'error': 'Email y password son requeridos'}, 400)
```

**Decir:**
> "Primero extraemos el email y password del request. Si alguno falta, retornamos un error 400."

#### 4.3 Autenticar usuario
```python
user = authenticate(username=email, password=password)

if user is None:
    return Response({'error': 'Credenciales inválidas'}, 401)

if not user.is_active:
    return Response({'error': 'Usuario inactivo'}, 403)
```

**Decir:**
> "Usamos la función authenticate de Django que valida automáticamente el password cifrado. Si las credenciales son incorrectas, retornamos 401. Si el usuario está inactivo, retornamos 403."

#### 4.4 Detectar rol
```python
rol = None
if user.groups.filter(name='Administrador').exists():
    rol = 'Administrador'
elif user.groups.filter(name='Maestro').exists():
    rol = 'Maestro'
elif user.groups.filter(name='Alumno').exists():
    rol = 'Alumno'
```

**Decir:**
> "Aquí detectamos el rol del usuario verificando a qué grupo pertenece. Django tiene un sistema de grupos integrado que usamos para manejar los roles."

#### 4.5 Generar JWT
```python
refresh = RefreshToken.for_user(user)

return Response({
    'token': str(refresh.access_token),
    'refresh': str(refresh),
    'user': {
        'id': user.id,
        'email': user.email,
        'first_name': user.first_name,
        'last_name': user.last_name
    },
    'rol': rol
}, status=200)
```

**Decir:**
> "Finalmente generamos dos tokens JWT: el access token que dura 24 horas y el refresh token que dura 7 días. Retornamos estos tokens junto con los datos del usuario y su rol. El frontend guardará este token y lo enviará en cada petición subsecuente."

#### 4.6 Demostración práctica
**[Pantalla dividida: IDE (izquierda) + Postman (derecha)]**

**Guión:**
> "Veamos esto en acción. Voy a hacer una petición POST a /login/ desde Postman."

**Mostrar en Postman:**
```
POST http://127.0.0.1:8000/login/
Content-Type: application/json

{
  "email": "alumno@test.com",
  "password": "password123"
}
```

**Mostrar la respuesta:**
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 42,
    "email": "alumno@test.com",
    "first_name": "Juan",
    "last_name": "Pérez"
  },
  "rol": "Alumno"
}
```

**Decir:**
> "Como pueden ver, recibimos el token exitosamente junto con los datos del usuario y el rol 'Alumno'. Voy a copiar este token porque lo necesitaremos para las siguientes peticiones."

---

### 5. ARCHIVO USERS.PY - CRUD ALUMNOS (7 minutos)
**[Pantalla: Abrir views/users.py]**

**Guión:**
> "Ahora vamos al archivo users.py que contiene todas las operaciones CRUD. Voy a explicar específicamente las vistas de alumnos porque las demás siguen el mismo patrón."

---

#### 5.1 AlumnoView - REGISTRO (3 minutos)

**Mostrar la clase completa:**
```python
class AlumnoView(generics.CreateAPIView):
    @transaction.atomic
    def post(self, request, *args, **kwargs):
```

**Decir:**
> "Esta es la vista de registro de alumnos. Usamos `@transaction.atomic` que es muy importante: garantiza que todas las operaciones se ejecuten completamente o ninguna. Si algo falla, todo se revierte automáticamente."

**Mostrar validación del serializer:**
```python
user = UserSerializer(data=request.data)

if user.is_valid():
```

**Decir:**
> "Primero validamos los datos con el UserSerializer. Esto verifica que los campos requeridos estén presentes y tengan el formato correcto."

**Mostrar validaciones únicas:**
```python
# Validar email único
if User.objects.filter(email=email).exists():
    return Response({"email": ["Este email ya está registrado"]}, status=400)

# Validar matrícula única
matricula = request.data.get("matricula")
if Alumnos.objects.filter(matricula=matricula).exists():
    return Response({"matricula": ["Esta matrícula ya existe"]}, status=400)

# Validar CURP única
curp = request.data.get("curp")
if curp and Alumnos.objects.filter(curp=curp).exists():
    return Response({"curp": ["Este CURP ya está registrado"]}, status=400)
```

**Decir:**
> "Tenemos tres validaciones importantes:"
> - "Verificamos que el email no esté registrado"
> - "Que la matrícula sea única"
> - "Y si se proporciona CURP, que también sea único"
> "Si alguna validación falla, retornamos un error 400 con un mensaje específico que el frontend puede mostrar."

**Mostrar creación del usuario:**
```python
user = User.objects.create(
    username=email,
    email=email,
    first_name=first_name,
    last_name=last_name,
    is_active=1
)
user.set_password(password)
user.save()
```

**Decir:**
> "Creamos el usuario en la tabla auth_user de Django. Es importante usar `set_password()` porque esto cifra la contraseña con bcrypt, nunca guardamos passwords en texto plano."

**Mostrar asignación de grupo:**
```python
group, created = Group.objects.get_or_create(name='Alumno')
group.user_set.add(user)
```

**Decir:**
> "Asignamos el usuario al grupo 'Alumno'. El método `get_or_create` obtiene el grupo si existe o lo crea si no existe."

**Mostrar creación del perfil:**
```python
alumno = Alumnos.objects.create(
    user=user,
    matricula=request.data.get("matricula"),
    fecha_nacimiento=request.data.get("fecha_nacimiento"),
    curp=request.data.get("curp", "").upper() if request.data.get("curp") else None,
    rfc=request.data.get("rfc", "").upper() if request.data.get("rfc") else None,
    edad=request.data.get("edad"),
    telefono=request.data.get("telefono"),
    ocupacion=request.data.get("ocupacion")
)
```

**Decir:**
> "Finalmente creamos el perfil de alumno. Noten que convertimos automáticamente CURP y RFC a mayúsculas. Esto es importante para mantener la consistencia de los datos."

**Mostrar respuesta exitosa:**
```python
return Response({
    "message": "Alumno registrado exitosamente",
    "alumno_created_id": alumno.id
}, status=201)
```

**Decir:**
> "Si todo sale bien, retornamos un status 201 (Created) con el ID del alumno creado."

**Demostración en Postman:**

**[Pantalla dividida: IDE + Postman]**

**Decir:**
> "Vamos a probar esto. Haré una petición POST para registrar un alumno."

```
POST http://127.0.0.1:8000/api/alumno/registro/
Content-Type: application/json

{
  "first_name": "María",
  "last_name": "González",
  "email": "maria@alumno.com",
  "password": "password123",
  "matricula": "A2025002",
  "fecha_nacimiento": "2001-08-20",
  "curp": "gogm010820mdfnrr01",
  "rfc": "gogm010820abc",
  "edad": 24,
  "telefono": "5559876543",
  "ocupacion": "Estudiante"
}
```

**Mostrar terminal del servidor:**
> "Miren en la terminal del servidor, pueden ver los logs que agregamos mostrando los datos recibidos y la confirmación de que el alumno fue creado."

---

#### 5.2 AlumnoAll - LISTAR (1 minuto)

**Mostrar la clase:**
```python
class AlumnoAll(generics.CreateAPIView):
    permission_classes = (permissions.IsAuthenticated,)
    
    def get(self, request, *args, **kwargs):
        administradores = Alumnos.objects.select_related('user').all()
        serializer = AlumnoSerializer(administradores, many=True)
        return Response(serializer.data, status=200)
```

**Decir:**
> "Esta vista lista todos los alumnos. Aquí vemos `permission_classes = (permissions.IsAuthenticated,)` que significa que REQUIERE autenticación JWT. Sin un token válido, esta petición fallará con 401."

**Destacar:**
> "Usamos `select_related('user')` que es una optimización muy importante. Esto hace un JOIN en SQL y carga los datos del usuario en la misma consulta. Sin esto, tendríamos N+1 queries: una por cada alumno para obtener sus datos de usuario."

**Demostración:**

**[Postman con header de Authorization]**

```
GET http://127.0.0.1:8000/lista-alumnos/
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json
```

**Decir:**
> "Noten que en los headers incluyo `Authorization: Bearer` seguido del token que obtuvimos en el login. Esto es crucial, el prefijo debe ser 'Bearer' con mayúscula inicial."

**Mostrar respuesta:**
```json
[
  {
    "id": 3,
    "user": {
      "id": 42,
      "first_name": "Juan",
      "last_name": "Pérez",
      "email": "juan@alumno.com"
    },
    "matricula": "A2025001",
    "curp": "PEGJ000515HDFRRN01",
    "rfc": "PEGJ000515XYZ",
    "edad": 25,
    "telefono": "5551234567",
    "ocupacion": "Estudiante",
    "creation": "2025-11-17T02:48:48Z"
  }
]
```

**Decir:**
> "La respuesta es un array de objetos JSON. Cada alumno incluye sus datos y los datos de su usuario relacionado, todo en una sola petición gracias a select_related."

---

#### 5.3 AlumnoEdit - GET/PUT/DELETE (3 minutos)

**Mostrar la clase:**
```python
class AlumnoEdit(generics.RetrieveUpdateDestroyAPIView):
    permission_classes = (permissions.IsAuthenticated,)
    queryset = Alumnos.objects.select_related('user').all()
    serializer_class = AlumnoSerializer
```

**Decir:**
> "Esta clase maneja tres operaciones: GET para obtener un alumno específico, PUT para actualizarlo y DELETE para eliminarlo."

**Método GET:**
```python
def get(self, request, pk, *args, **kwargs):
    try:
        alumno = Alumnos.objects.select_related('user').get(pk=pk)
        serializer = AlumnoSerializer(alumno)
        return Response(serializer.data, status=200)
    except Alumnos.DoesNotExist:
        return Response({"error": "Alumno no encontrado"}, status=404)
```

**Decir:**
> "El método GET recibe el ID como parámetro `pk`. Buscamos el alumno y si existe lo retornamos serializado. Si no existe, retornamos 404."

**Demostración GET:**
```
GET http://127.0.0.1:8000/alumno-edit/3/
Authorization: Bearer <token>
```

**Método PUT:**
```python
@transaction.atomic
def put(self, request, pk, *args, **kwargs):
    alumno = Alumnos.objects.select_related('user').get(pk=pk)
    
    # Actualizar User
    if 'email' in request.data:
        email = request.data['email']
        if User.objects.filter(email=email).exclude(id=alumno.user.id).exists():
            return Response({"email": ["Este email ya está registrado"]}, status=400)
        alumno.user.email = email
        alumno.user.username = email
    
    alumno.user.save()
    
    # Actualizar Alumno
    if 'curp' in request.data:
        curp = request.data['curp']
        if curp:
            if Alumnos.objects.filter(curp=curp).exclude(id=pk).exists():
                return Response({"curp": ["Este CURP ya está registrado"]}, status=400)
            alumno.curp = curp.upper()
    
    alumno.save()
```

**Decir:**
> "El método PUT actualiza el alumno. Nuevamente usamos `@transaction.atomic`. Lo importante aquí es que validamos la unicidad pero EXCLUYENDO el registro actual. Usamos `.exclude(id=alumno.user.id)` para que no se compare consigo mismo."

**Demostración PUT:**
```
PUT http://127.0.0.1:8000/alumno-edit/3/
Authorization: Bearer <token>
Content-Type: application/json

{
  "first_name": "Juan Carlos",
  "telefono": "5559999999",
  "edad": 26
}
```

**Decir:**
> "Voy a actualizar el nombre y teléfono del alumno. Solo enviamos los campos que queremos cambiar, no es necesario enviar todo el objeto."

**Método DELETE:**
```python
def delete(self, request, pk, *args, **kwargs):
    alumno = Alumnos.objects.get(pk=pk)
    user = alumno.user
    alumno.delete()
    user.delete()
    return Response({"message": "Alumno eliminado exitosamente"}, status=200)
```

**Decir:**
> "El DELETE es directo. Obtenemos el alumno y su usuario, eliminamos ambos y retornamos confirmación. Eliminamos primero el perfil y luego el usuario para evitar problemas de foreign keys."

**Demostración DELETE:**
```
DELETE http://127.0.0.1:8000/alumno-edit/3/
Authorization: Bearer <token>
```

**Decir:**
> "Y si ahora intento hacer GET al mismo alumno..."

```
GET http://127.0.0.1:8000/alumno-edit/3/
Authorization: Bearer <token>

Response: 404 Not Found
{"error": "Alumno no encontrado"}
```

**Decir:**
> "Recibimos 404 porque ya no existe. Perfecto."

---

### 6. MAESTROS - CAMPO ESPECIAL MATERIAS (2 minutos)

**[Pantalla: Mostrar MaestroView en users.py]**

**Guión:**
> "Los maestros y administradores siguen el mismo patrón que acabamos de ver, pero quiero mostrarles un detalle especial de los maestros: el campo 'materias'."

**Mostrar código:**
```python
materias = request.data.get('materias', [])
materias_str = ','.join(materias) if materias else ''

maestro = Maestros.objects.create(
    user=user,
    clave_maestro=request.data.get("clave_maestro"),
    area_investigacion=request.data.get("area_investigacion"),
    cubiculo=request.data.get("cubiculo"),
    materias=materias_str  # Guardamos como CSV
)
```

**Decir:**
> "El frontend envía las materias como un array JSON, por ejemplo: ['Matemáticas', 'Física', 'Química']. Pero en la base de datos lo guardamos como un string CSV: 'Matemáticas,Física,Química'. Hacemos esto usando `.join()` que convierte el array en string separado por comas."

**Demostración en Postman:**
```
POST http://127.0.0.1:8000/api/maestro/registro/
Content-Type: application/json

{
  "first_name": "Pedro",
  "last_name": "Ramírez",
  "email": "pedro@maestro.com",
  "password": "maestro123",
  "clave_maestro": "MAE002",
  "area_investigacion": "Física Aplicada",
  "cubiculo": "C-310",
  "materias": ["Física I", "Física II", "Termodinámica"]
}
```

**Mostrar respuesta y luego GET:**
```
GET http://127.0.0.1:8000/lista-maestros/
Authorization: Bearer <token>

Response:
{
  ...
  "materias": "Física I,Física II,Termodinámica"
}
```

**Decir:**
> "Cuando listamos, el backend devuelve el CSV tal cual. Es responsabilidad del frontend convertirlo de vuelta a array usando `.split(',')` si lo necesita."

---

### 7. ADMINISTRADORES (1 minuto)

**[Pantalla: Mostrar brevemente AdminView, AdminAll, AdminEdit]**

**Guión:**
> "Los administradores siguen exactamente el mismo patrón que vimos con alumnos. Tienen su vista de registro AdminView, su lista AdminAll y su CRUD individual AdminEdit. La única diferencia son los campos específicos como 'clave_admin' y 'rfc'."

**Scroll rápido por el código sin detenerse mucho:**
> "Validaciones únicas, transacción atómica, asignación de grupo 'Administrador', todo igual. No voy a repetir la explicación porque ya lo vieron en detalle con alumnos."

---

### 8. CONCEPTOS CLAVE (1 minuto)

**[Pantalla: Crear diapositiva o mostrar código destacando decoradores]**

**Guión:**
> "Antes de terminar, quiero destacar algunos conceptos clave que vimos:"

**Mostrar en pantalla:**

**1. @transaction.atomic**
```python
@transaction.atomic
def post(self, request):
    # Todas las operaciones se ejecutan o ninguna
```
**Decir:**
> "Garantiza atomicidad: todo se guarda o nada. Si algo falla, se hace rollback automático."

**2. @permission_classes**
```python
@permission_classes([AllowAny])      # No requiere token
permission_classes = (permissions.IsAuthenticated,)  # Requiere token
```
**Decir:**
> "Controla quién puede acceder a cada endpoint."

**3. select_related()**
```python
Alumnos.objects.select_related('user').all()
```
**Decir:**
> "Optimización SQL: hace JOIN y evita múltiples queries."

**4. Validaciones únicas con exclude()**
```python
User.objects.filter(email=email).exclude(id=current_user_id).exists()
```
**Decir:**
> "Para validar unicidad al actualizar sin compararse consigo mismo."

**5. Conversión automática**
```python
curp.upper()  # CURP siempre en mayúsculas
','.join(materias)  # Array a CSV
```

---

### 9. DEMOSTRACIÓN INTEGRADA (2 minutos)

**[Pantalla dividida: Postman + Terminal del servidor]**

**Guión:**
> "Para finalizar, voy a mostrarles un flujo completo desde el registro hasta la eliminación."

**Paso 1: Registro**
```
POST /api/alumno/registro/
{...datos completos...}
```
**Decir:**
> "Registramos un alumno nuevo."

**Paso 2: Login**
```
POST /login/
{email, password}
```
**Decir:**
> "Hacemos login y obtenemos el token."

**Paso 3: Listar**
```
GET /lista-alumnos/
Authorization: Bearer <token>
```
**Decir:**
> "Listamos todos los alumnos con autenticación."

**Paso 4: Actualizar**
```
PUT /alumno-edit/4/
Authorization: Bearer <token>
{edad: 25}
```
**Decir:**
> "Actualizamos datos."

**Paso 5: Eliminar**
```
DELETE /alumno-edit/4/
Authorization: Bearer <token>
```
**Decir:**
> "Y finalmente eliminamos."

**Mientras haces esto, señalar la terminal:**
> "Noten en la terminal del servidor todos los logs que agregamos mostrando cada operación: las peticiones recibidas, las validaciones ejecutándose, los registros creados. Esto es muy útil para depuración."

---

### 10. CIERRE (30 segundos)

**[Pantalla: Tu cara o resumen en pantalla]**

**Guión:**
> "Muy bien, en resumen, vimos cómo configuramos las URLs en urls.py, cómo manejamos la autenticación con JWT en auth.py, y cómo implementamos el CRUD completo para alumnos, maestros y administradores en users.py."

> "Los puntos clave son: usar transacciones atómicas para garantizar integridad, validar datos antes de guardar, optimizar consultas con select_related, y manejar correctamente la autenticación JWT."

> "Espero que esta explicación les haya sido útil. Si tienen preguntas, déjenlas en los comentarios. ¡Hasta la próxima!"

**[Fade out]**

---

## CHECKLIST ANTES DE GRABAR

### Preparación del entorno:
- [ ] Servidor Django corriendo en http://127.0.0.1:8000
- [ ] Base de datos con datos de prueba
- [ ] Postman/Thunder Client abierto con colección preparada
- [ ] Terminal visible mostrando logs del servidor
- [ ] IDE con theme oscuro y fuente grande (16-18pt)

### Requests preparados en Postman:

**Carpeta: Autenticación**
- [ ] POST /login/ (con credenciales válidas)

**Carpeta: Alumnos**
- [ ] POST /api/alumno/registro/ (datos de alumno nuevo)
- [ ] GET /lista-alumnos/ (con token en header)
- [ ] GET /alumno-edit/3/
- [ ] PUT /alumno-edit/3/ (con algunos campos)
- [ ] DELETE /alumno-edit/3/

**Carpeta: Maestros**
- [ ] POST /api/maestro/registro/ (con array de materias)
- [ ] GET /lista-maestros/

**Carpeta: Administradores**
- [ ] POST /api/administrador/registro/
- [ ] GET /lista-admins/

### Headers guardados:
- [ ] Authorization: Bearer <token-válido>
- [ ] Content-Type: application/json

### Archivos a mostrar:
- [ ] urls.py
- [ ] views/auth.py
- [ ] views/users.py
- [ ] models.py (opcional, solo mencionar)

---

## TIPS PARA MEJORAR EL VIDEO

### Durante la grabación:
1. **Habla pausado y claro** - La gente necesita tiempo para procesar
2. **Usa el cursor** - Señala el código mientras explicas
3. **Divide la pantalla** - IDE a la izquierda, Postman a la derecha
4. **Muestra los logs** - Terminal del servidor visible
5. **Pausa entre secciones** - Facilita la edición después

### Edición:
1. **Agrega títulos** - "URLS", "LOGIN", "CRUD ALUMNOS", etc.
2. **Zoom in** - Acerca el código importante
3. **Highlight** - Resalta líneas clave con rectángulo o flecha
4. **Música de fondo** - Muy baja, no invasiva
5. **Corta pausas largas** - Mantén el ritmo

### Contenido extra (opcional):
1. **Timestamps en descripción:**
   - 0:00 Introducción
   - 0:30 Estructura del proyecto
   - 1:00 URLs
   - 3:00 Login (auth.py)
   - 6:00 CRUD Alumnos
   - 13:00 Maestros
   - 15:00 Conclusiones

2. **Links en descripción:**
   - Repositorio GitHub
   - Documentación Django REST Framework
   - Tutorial de JWT

---

## PUNTOS MÁS IMPORTANTES A DESTACAR

1. **Transacciones atómicas** - Garantizan integridad
2. **Validaciones únicas** - Evitan duplicados
3. **select_related()** - Optimización de queries
4. **JWT con Bearer** - Autenticación stateless
5. **Grupos de Django** - Manejo de roles
6. **Conversión de datos** - CURP upper, materias CSV
7. **Manejo de errores** - Respuestas claras con status codes correctos

---

## TIEMPO ESTIMADO POR SECCIÓN

| Sección | Tiempo |
|---------|--------|
| Introducción | 0:30 |
| Estructura archivos | 0:30 |
| URLs | 2:00 |
| Login (auth.py) | 3:00 |
| CRUD Alumnos | 7:00 |
| Maestros | 2:00 |
| Administradores | 1:00 |
| Conceptos clave | 1:00 |
| Demo integrada | 2:00 |
| Cierre | 0:30 |
| **TOTAL** | **≈20 min** |

*Nota: Con edición y cortes quedará en 12-15 minutos*

---

## ALTERNATIVA: VIDEO CORTO (5-7 min)

Si necesitas un video más corto, enfócate solo en:

1. **URLs** (1 min) - Mostrar todas las rutas
2. **Login** (2 min) - Explicar JWT
3. **Un ejemplo CRUD completo** (3 min) - Solo alumnos
4. **Conclusión** (1 min)

Menciona que maestros y admins siguen el mismo patrón sin mostrar el código.

---

**¡Éxito con tu video!**
